// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model User {
  user_id          String     @id @default(cuid())
  user_name        String     @unique
  user_email       String?    @unique
  user_image       String?
  user_description String?
  playlists        Playlist[] // Défini le contenu comme une liste de Post. ([])

  // Next Auth
  accounts         Account[]
  sessions         Session[]
}

model Playlist {
  playlist_id         String  @id @default(cuid())
  playlist_name       String
  playlist_image      String? // Si on veut rattacher une image à la playlist.
  playlist_visibility Boolean // Si on veut mettre la playlist en mode publique ou privé. (true: publique, false : privé)


  owner   User?   @relation(fields: [ownerId], references: [user_id])
  ownerId String?

  // Une playlist peut avoir plusieurs musiques.
  playlist_songs Song[]
}

model Song {
  song_id    Int    @id @default(autoincrement())
  spotify_id Int // ID associés à la musique correspondant à l'API Spotify
  youtube_id Int // ID associés à la musique correspondant à l'API Youtube
  song_name  String
  song_year  Int?

  // Une musique peut avoir plusieurs Genre et un Genre peut avoir plusieurs musiques.
  song_genres Genre[]

  // Une Musique est rattaché à un artiste (même une musique en colab reste à un artiste)
  song_artist   Artist @relation(fields: [song_artistId], references: [artist_id])
  song_artistId String

  // Une Musique est dans 1 seul Album.
  song_album   Album  @relation(fields: [song_albumId], references: [album_id])
  song_albumId String

  // Une musique appartient à plusieurs playlist.
  song_playlist   Playlist? @relation(fields: [song_playlistId], references: [playlist_id])
  song_playlistId String?
}

model Artist {
  artist_id   String @id @default(cuid()) // PK
  artist_name String

  // Un artiste peut avoir plusieurs Musiques.
  artist_song Song[]
}

model Genre {
  genre_id   String @id @default(cuid()) // PK
  genre_name String

  // Un genre peut avoir plusieurs Musiques.
  genre_songs Song[]
}

model Album {
  album_id   String @id @default(cuid())
  album_name String
  album_year Int

  // Un album peut avoir plusieurs musiques.
  album_song Song[]
}

// Les tables nécessaires pour NextAuth :
// https://next-auth.js.org/adapters/prisma

// ===== Account ======
// Fourni les informations à OAuth associé aux Users. (contient surtout les infos pour un TokenSet)

// id  :  Primary key
// type :
// provider :
// providerAccountId :
// refreshToken :
// accessToken :
// expiresAt : Temps en seconde pour l'expiration du token.
// tokenType :
// scope :
// idToken :
// sessionState :
// oauthTokenSecret :
// oauthToken :

// user   User @relation(fields: [userId], references: [id], onDelete: Cascade) : 1 utilisateur peut avoir plusieurs compte mais 1 compte a 1 seul User.
// userId Int

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?
  oauth_token_secret String?
  oauth_token        String?
  user               User    @relation(fields: [userId], references: [user_id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

// Va nous permettre de gérer la session active de l'user.
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [user_id], onDelete: Cascade)
}

// Permet de stocker les tokens valides donnée par les providers lors de la connexion.
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
